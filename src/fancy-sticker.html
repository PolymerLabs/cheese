<!--
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The compconste set of authors may be found at http://polymer.github.io/AUTHORS.txt
The compconste set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../bower_components/polymer/polymer-element.html">

<dom-module id="fancy-sticker">
<template>
<style>
  :host {
    perspective: 800px;
  }

  img {
    position: absolute;
    transform-origin: center center;
    will-change: transform;
    width: 128px;
    height: 128px;
  }
  img.moving {
    opacity: 0.7;
  }
  img.removing {
    opacity: 0.3;
  }
</style>

<img id="img" src="[[_getImgSrc(themePath, svgName)]]" on-load="_stickerLoad"
    on-touchstart="_touchstart" on-touchmove="_touchmove" on-touchend="_touchend">
</template>

<script>
customElements.define('fancy-sticker', class extends Polymer.Element {
  static get is() { return 'fancy-sticker' }

  static get properties() {
    return {
      svgName: {
        type: String
      },

      themePath: {
        type: String,
        value: () => 'stickers'
      },

      bounds: {
        type: Object
      },

      anchor: {
        type: Object
      },

      rotation: {
        type: Object
      },

      debug: {
        type: Boolean
      }
    };
  }

  ready() {
    super.ready();
    const anchor = this.anchor || {};
    this._ax = Number.isFinite(anchor.x) ? anchor.x : 0.5;
    this._ay = Number.isFinite(anchor.y) ? anchor.y : 0.5;
    // Setup transform origin according to anchor.
    this.$.img.style.transformOrigin = `${this._ax*100}% ${this._ay*100}%`;

    // Compute initial x/y values from bounds and anchor.
    const bounds = this.bounds || {left: 40, top: 40, width: 128, height: 128};
    this._x = bounds.left + (bounds.width - 128) * this._ax;
    this._y = bounds.top + (bounds.height - 128) * this._ay;
    this._scale = bounds.width / 128;
    
    // Compute rotation.
    const rotation = this.rotation || {};
    this._rx = rotation.x || 0;
    this._ry = rotation.y || 0;
    this._rz = rotation.z || 0;

    this._positionIcon();
  }

  static get observers() {
    return [
      '_handleTestDiv(debug, bounds)'
    ];
  }

  _touchstart(event) {
    event.preventDefault();

    this._setBaseCoordinates(event.touches);

    // On the first touch, start a timer that will make the sticker movable.
    if (event.touches.length === 1) {
      this._baseTouch = event.touches[0];
      this._timer = window.setTimeout(() => {
        this.$.img.classList.add('moving');
        this._timer = null;
      }, 300);
    }
  }

  _touchmove(event) {
    if (!this.$.img.classList.contains('moving')) {
      if (this._timer) {
        const distance = this._distanceBetween(event.touches[0], this._baseTouch);
        if (distance > 10) {
          // If there is significant touch movement before the timer elapses, let the touch
          // events propagate to the carousel until all touches have finished.
          window.clearTimeout(this._timer);
          this._timer = null;
        }
      }
      return;
    }

    event.preventDefault();
    event.stopPropagation();

    const t1 = event.touches[0];
    if (event.touches.length > 1) {
      const t2 = event.touches[1];
      const distance = this._distanceBetween(t1, t2);
      // It's possible for _baseDistance to be 0 when the second touch starts from outside
      // the sticker, in which case there is not touchstart event, but there will be 
      // touchmove events.
      if (this._baseDistance > 0) {
        const scaleChange = distance / this._baseDistance;
        this._baseX *= scaleChange;
        this._baseY *= scaleChange;
        this._scale *= scaleChange;
      }
      this._baseDistance = distance;
    }
    this._x = t1.pageX - this._baseX;
    this._y = t1.pageY - this._baseY;

    this.$.img.classList.toggle('removing', t1.pageY < 50);
    this._positionIcon();
  }

  _touchend(event) {
    event.preventDefault();

    if (event.touches.length) {
      event.stopPropagation();
      this._setBaseCoordinates(event.touches);
    } else {
      if (this.$.img.classList.contains('removing')) {
        this.parentNode.removeChild(this);
      } else {
        this.$.img.classList.remove('moving');
      }
    }
  }

  drawIntoContext(ctx) {
    const w = this._scale * this.$.img.width;
    const h = this._scale * this.$.img.height;
    ctx.drawImage(this.$.img, this._x, this._y, w, h);
  }

  _distanceBetween(t1, t2) {
    const a = t1.pageX - t2.pageX;
    const b = t1.pageY - t2.pageY;
    return Math.sqrt(a * a + b * b);
  }

  _positionIcon() {
    this.$.img.style.transform = `translate3d(${this._x}px,${this._y}px,0) rotate3d(1,0,0,${this._rx}deg) rotate3d(0,1,0,${this._ry}deg) rotate3d(0,0,1,${this._rz}deg) scale(${this._scale})`;
  }

  _setBaseCoordinates(touches) {
    const t1 = touches[0];
    this._baseX = t1.pageX - this._x;
    this._baseY = t1.pageY - this._y;

    if (touches.length > 1) {
      const t2 = touches[1];
      this._baseDistance = this._distanceBetween(t1, t2);
    } else {
      this._baseDistance = 0;
    }
  }

  _getImgSrc(theme, name) {
    return `${theme}/${name}.svg`;
  }

  _stickerLoad() {
    this.dispatchEvent(new CustomEvent('sticker-load', { bubbles: true, composed: true }));
  }

  
  _handleTestDiv(debug, bounds) {
    if (!debug) {
      if (this._testDiv) this._testDiv.style.display = 'none';
    } else if (bounds) {
      if (!this._testDiv) {
        this._testDiv = document.createElement('div');
        this._testDiv.style.border = '1px solid red';
        this._testDiv.style.pointerEvents = 'none';
        this._testDiv.style.position = 'absolute';
        this.shadowRoot.appendChild(this._testDiv);
      }
      for (let dim in bounds) this._testDiv.style[dim] = bounds[dim] + 'px';
      this._testDiv.style.display = '';
    }
  }
});
</script>
</dom-module>
