<!--
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The compconste set of authors may be found at http://polymer.github.io/AUTHORS.txt
The compconste set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-repeat.html">
<link rel="import" href="fancy-sticker.html">

<dom-module id="fancy-sticker-layer">
  <template>
    <template is="dom-repeat" items="[[stickers]]" as="sticker">
      <fancy-sticker name="[[sticker.name]]" bounds="[[sticker.bounds]]"></fancy-sticker>
    </template>
  </template>

  <script>
    customElements.define('fancy-sticker-layer', class extends Polymer.Element {
      static get is() {
        return 'fancy-sticker-layer';
      }

      static get properties() {
        return {
          stickerType: {
            type: String,
            value: () => 'emotion'
          },
          annotations: {
            type: Object,
            value: null
          },
          faces: {
            type: Array,
            computed: '_computeFaces(annotations)'
          },
          stickers: {
            type: Array,
            computed: '_computeStickers(stickerType, faces)'
          }
        };
      }

      _computeFaces(annotations) {
        // No faces detected.
        if (!annotations || !annotations.faceAnnotations) return null;
        return annotations.faceAnnotations.map(face => {
          const faceBounds = this._computeBounds(face.boundingPoly.vertices, [0, 1, 2, 3]);
          const emotionType = this._computeEmotionType(face);
          const landmarks = this._computeLandmarks(face);

          const otherBounds = {};

          // belowFace
          otherBounds.belowFace = Object.assign({}, faceBounds);
          otherBounds.belowFace.top += otherBounds.belowFace.height - 10;

          // aboveFace
          otherBounds.aboveFace = Object.assign({}, faceBounds);
          otherBounds.aboveFace.top -= otherBounds.aboveFace.height;

          // leftEye
          otherBounds.leftEye = this._computeBounds(landmarks, [
            'LEFT_EYE_PUPIL'
          ]);
          otherBounds.leftEye.width = otherBounds.leftEye.height = faceBounds.width * 0.3;
          otherBounds.leftEye.left -= otherBounds.leftEye.width / 2;
          otherBounds.leftEye.top -= otherBounds.leftEye.width / 2;

          // rightEye
          otherBounds.rightEye = this._computeBounds(landmarks, [
            'RIGHT_EYE_PUPIL'
          ]);
          otherBounds.rightEye.width = otherBounds.rightEye.height = faceBounds.width * 0.3;
          otherBounds.rightEye.left -= otherBounds.rightEye.width / 2;
          otherBounds.rightEye.top -= otherBounds.rightEye.height / 2;

          // eyes
          otherBounds.eyes = this._computeBounds(landmarks, [
            'MIDPOINT_BETWEEN_EYES'
          ]);
          otherBounds.eyes.width = otherBounds.eyes.height = faceBounds.width * 0.7;
          otherBounds.eyes.left -= otherBounds.eyes.width / 2;
          otherBounds.eyes.top -= otherBounds.eyes.height / 2;

          // nose
          otherBounds.nose = this._computeBounds(landmarks, [
            'MIDPOINT_BETWEEN_EYES',
            'NOSE_TIP',
            'NOSE_BOTTOM_RIGHT',
            'NOSE_BOTTOM_LEFT',
            'NOSE_BOTTOM_CENTER'
          ]);
          otherBounds.nose.left += otherBounds.nose.width / 2 - otherBounds.nose.height / 2;
          otherBounds.nose.width = otherBounds.nose.height;

          // mouth
          otherBounds.mouth = this._computeBounds(landmarks, [
            'MOUTH_LEFT',
            'MOUTH_RIGHT',
            'LOWER_LIP',
            'UPPER_LIP'
          ]);
          otherBounds.mouth.top += otherBounds.mouth.height / 2 - otherBounds.mouth.width / 2;
          otherBounds.mouth.height = otherBounds.mouth.width;

          return {
            faceBounds,
            emotionType,
            otherBounds
          };
        });
      }

      _computeStickers(type, faces) {
        // No faces detected.
        if (!type || !faces) return null;

        // Support combos!
        const types = type.split('+');
        return faces.reduce((res, face) => {
          types.forEach(type => {
            const sticker = this._getSticker(type, face);
            sticker && res.push(sticker);
          });
          return res;
        }, []);
      }

      _getSticker(type, face) {
        if (type === 'emotion') {
          return {
            name: face.emotionType,
            bounds: face.faceBounds
          };
        }
        if (type === 'tie') {
          return {
            name: type,
            bounds: face.otherBounds.belowFace
          };
        }
        if (face.otherBounds[type]) {
          return {
            name: type,
            bounds: face.otherBounds[type]
          };
        }
      }

      _computeEmotionType(faceAnnotation) {
        const decreasingLikelihoods = ['VERY_LIKELY', 'LIKELY', 'POSSIBLE'];
        for (let i = 0; i < decreasingLikelihoods.length; ++i) {
          const currentLikelihood = decreasingLikelihoods[i];
          if (faceAnnotation.joyLikelihood === currentLikelihood) {
            return 'joy';
          }
          if (faceAnnotation.sorrowLikelihood === currentLikelihood) {
            return 'sorrow';
          }
          if (faceAnnotation.angerLikelihood === currentLikelihood) {
            return 'anger';
          }
          if (faceAnnotation.surpriseLikelihood === currentLikelihood) {
            return 'surprise';
          }
        }
        return 'normal';
      }

      _computeLandmarks(faceAnnotation) {
        return faceAnnotation.landmarks.reduce((res, lm) => {
          res[lm.type] = lm.position;
          return res;
        }, {});
      }

      _computeBounds(landmarks, keys) {
        const minMax = this._computeMinMax(landmarks, keys);
        const left = minMax.min.x;
        const top = minMax.min.y;
        const width = minMax.max.x - left;
        const height = minMax.max.y - top;
        return {
          top,
          left,
          width,
          height
        };
      }

      _computeMinMax(landmarks, keys) {
        return keys.reduce((res, key) => {
          const position = landmarks[key] || {};
          res.min.x = Math.min(position.x || 0, res.min.x);
          res.min.y = Math.min(position.y || 0, res.min.y);
          res.min.z = Math.min(position.z || 0, res.min.z);
          res.max.x = Math.max(position.x || 0, res.max.x);
          res.max.y = Math.max(position.y || 0, res.max.y);
          res.max.z = Math.max(position.z || 0, res.max.z);
          return res;
        }, {
          min: {
            x: Infinity,
            y: Infinity,
            z: Infinity
          },
          max: {
            x: -Infinity,
            y: -Infinity,
            z: -Infinity
          }
        });
      }
    });
  </script>
</dom-module>