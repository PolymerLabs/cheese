<!--
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The compconste set of authors may be found at http://polymer.github.io/AUTHORS.txt
The compconste set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-repeat.html">
<link rel="import" href="fancy-sticker.html">

<dom-module id="fancy-sticker-layer">
  <template>
    <template is="dom-repeat" items="[[stickers]]" as="sticker">
      <fancy-sticker name="[[sticker.name]]" bounds="[[sticker.bounds]]"></fancy-sticker>
    </template>
  </template>

  <script>
    const boundsMap = {
      eyes: [
        'LEFT_EYE_BOTTOM_BOUNDARY',
        'RIGHT_EYE_BOTTOM_BOUNDARY',
        'LEFT_EYE_LEFT_CORNER',
        'RIGHT_EYE_RIGHT_CORNER',
        'LEFT_EYE_TOP_BOUNDARY',
        'RIGHT_EYE_TOP_BOUNDARY'
      ],
      leftEye: [
        'LEFT_EYE_PUPIL',
      ],
      rightEye: [
        'RIGHT_EYE_PUPIL',
      ],
      nose: [
        'MIDPOINT_BETWEEN_EYES',
        'NOSE_TIP',
        'NOSE_BOTTOM_RIGHT',
        'NOSE_BOTTOM_LEFT',
        'NOSE_BOTTOM_CENTER'
      ],
      mouth: [
        'MOUTH_LEFT',
        'MOUTH_RIGHT',
        'LOWER_LIP',
        'UPPER_LIP'
      ],
    };

    customElements.define('fancy-sticker-layer', class extends Polymer.Element {
      static get is() {
        return 'fancy-sticker-layer';
      }

      static get properties() {
        return {
          stickerType: {
            type: String,
            value: () => 'emotion'
          },
          annotations: {
            type: Object,
            value: null
          },
          faces: {
            type: Array,
            computed: '_computeFaces(annotations)'
          },
          stickers: {
            type: Array,
            computed: '_computeStickers(stickerType, faces)'
          }
        };
      }

      _computeFaces(annotations) {
        // No faces detected.
        if (!annotations || !annotations.faceAnnotations) return null;
        return annotations.faceAnnotations.map(face => {
          const faceBounds = this._computeBounds(face.boundingPoly.vertices, [0, 1, 2, 3]);
          const emotionType = this._computeEmotionType(face);
          const landmarks = this._computeLandmarks(face);

          const otherBounds = {};

          const belowFaceBounds = Object.assign({}, faceBounds);
          belowFaceBounds.top += belowFaceBounds.height - 10;
          otherBounds.belowFace = belowFaceBounds;

          const aboveFaceBounds = Object.assign({}, faceBounds);
          aboveFaceBounds.top -= aboveFaceBounds.height;
          otherBounds.aboveFace = aboveFaceBounds;

          for (let name in boundsMap) {
            const bounds = this._computeBounds(landmarks, boundsMap[name]);
            otherBounds[name] = bounds;
          }

          return {
            faceBounds,
            emotionType,
            otherBounds
          };
        });
      }

      _computeStickers(type, faces) {
        // No faces detected.
        if (!type || !faces) return null;

        // Support combos!
        const types = type.split('+');
        return faces.reduce((res, face) => {
          types.forEach(type => {
            const sticker = this._getSticker(type, face);
            sticker && res.push(sticker);
          });
          return res;
        }, []);
      }

      _getSticker(type, face) {
        if (type === 'emotion') {
          return {
            name: face.emotionType,
            bounds: face.faceBounds
          };
        }
        if (type === 'tie') {
          return {
            name: type,
            bounds: face.otherBounds.belowFace
          };
        }
        if (face.otherBounds[type]) {
          return {
            name: type,
            bounds: face.otherBounds[type]
          };
        }
      }

      _computeEmotionType(faceAnnotation) {
        const decreasingLikelihoods = ['VERY_LIKELY', 'LIKELY', 'POSSIBLE'];
        for (let i = 0; i < decreasingLikelihoods.length; ++i) {
          const currentLikelihood = decreasingLikelihoods[i];
          if (faceAnnotation.joyLikelihood === currentLikelihood) {
            return 'joy';
          }
          if (faceAnnotation.sorrowLikelihood === currentLikelihood) {
            return 'sorrow';
          }
          if (faceAnnotation.angerLikelihood === currentLikelihood) {
            return 'anger';
          }
          if (faceAnnotation.surpriseLikelihood === currentLikelihood) {
            return 'surprise';
          }
        }
        return 'normal';
      }

      _computeLandmarks(faceAnnotation) {
        return faceAnnotation.landmarks.reduce((res, lm) => {
          res[lm.type] = lm.position;
          return res;
        }, {});
      }

      _computeBounds(landmarks, keys) {
        const minMax = this._computeMinMax(landmarks, keys);
        const left = minMax.min.x;
        const top = minMax.min.y;
        const width = minMax.max.x - left;
        const height = minMax.max.y - top;
        return {
          top,
          left,
          width,
          height
        };
      }

      _computeMinMax(landmarks, keys) {
        return keys.reduce((res, key) => {
          const position = landmarks[key] || {};
          res.min.x = Math.min(position.x || 0, res.min.x);
          res.min.y = Math.min(position.y || 0, res.min.y);
          res.min.z = Math.min(position.z || 0, res.min.z);
          res.max.x = Math.max(position.x || 0, res.max.x);
          res.max.y = Math.max(position.y || 0, res.max.y);
          res.max.z = Math.max(position.z || 0, res.max.z);
          return res;
        }, {
          min: {
            x: Infinity,
            y: Infinity,
            z: Infinity
          },
          max: {
            x: -Infinity,
            y: -Infinity,
            z: -Infinity
          }
        });
      }
    });
  </script>
</dom-module>